# Как бы мне написать DFT побыстрее?

Предположим, что мы уже знаем, как работает преобразование Фурье, по крайней мере в лоб. Одна проблема - наше **быстрое** преобразование Фурье в общем виде невероятно **медленное**.  \
$O(n^2) * C$ операций как минимум, где $C$ - это довольно большой численный коэффициент (вычисление тригонометрии медленнее умножения раз эдак в 25, и это в лучшем случае).

Джеймс Вильям Кули и Джон Тьюки, к счастью, уже поработали за нас и разработали алгоритм, который работает за $O(N * log(N))$ и, при правильном к нему подходе, может полностью исключить вычисление тригонометрии на лету. Как выкинуть вычисление синусов и косинусов, я вам не расскажу - догадайтесь сами.

Итак, алгоритм Кули-Тьюки позволяет нам собрать из двух коротких DFT длин $n_1$ и $n_2$ DFT на $n_1 * n_2$ точек.  \
В общем виде, опустив выделение памяти и прочие формальности, давайте представим его так:
```c
extern void refDftFwd(const cfloat32_t *pSrc, cfloat32_t *pDst)
{
    uint32_t n1 = n1;
    uint32_t n2 = n2;
    uint32_t length = n1 * n2;
```
**Шаг 1** - транспонируем входные данные по столбцам, по которым будем вычислять $n_2$-точечные DFT
```c
    for (uint32_t i2 = 0; i2 < n2; i2++)
    {
        for (uint32_t i1 = 0; i1 < n1; i1++)
        {
            tmpSrc[i2 + i1 * n2].re = pSrc[n1 * i2 + i1].re;
            tmpSrc[i2 + i1 * n2].im = pSrc[n1 * i2 + i1].im;
        }
    }
```
**Шаг 2** - вычисляем $n_1$ $n_2$-точечных DFT. _Напоминаю, что мы их уже написали_
```c
    for (uint32_t i1 = 0; i1 < n1; i1++)
    {
        dftN2Fwd(&tmpSrc[i1 * n2], &tmpDst[i1 * n2]);
    }
```
**Шаг 3** - производим поэлементное комплексное умножение на тригонометрические константы. _Упражнение: догадайтесь, почему `i1` начинается с единицы, а не с нуля_
```c
    for (uint32_t i1 = 1; i1 < n1; i1++)
    {
        for (uint32_t i2 = 0; i2 < n2; i2++)
        {
            float twdRe = cos(_2PI * i2 * i1 / length);
            float twdIm =-sin(_2PI * i2 * i1 / length);
            float re = tmpDst[i1 * n2 + i2].re * twdRe - tmpDst[i1 * n2 + i2].im * twdIm;
            float im = tmpDst[i1 * n2 + i2].im * twdRe + tmpDst[i1 * n2 + i2].re * twdIm;
            tmpDst[i1 * n2 + i2].re = re;
            tmpDst[i1 * n2 + i2].im = im;
        }
    }
```
**Шаг 4** - транспонируем промежуточные результаты по строкам для $n_1$-точечных DFT
```c
    for (uint32_t i1 = 0; i1 < n1; i1++)
    {
        for (uint32_t i2 = 0; i2 < n2; i2++)
        {
            tmpSrc[n1 * i2 + i1].re = tmpDst[n2 * i1 + i2].re;
            tmpSrc[n1 * i2 + i1].im = tmpDst[n2 * i1 + i2].im;
        }
    }
```
**Шаг 5** - вычисляем $n_2$ $n_1$-точечных DFT
```c
    for (uint32_t i2 = 0; i2 < n2; i2++)
    {
        dftN1Fwd(&tmpSrc[i2 * n1], &tmpDst[i2 * n1]);
    }
```
**Шаг 6** - правильно расставляем результаты вычислений.
```c
    for (uint32_t i2 = 0; i2 < n2; i2++)
    {
        for (uint32_t i1 = 0; i1 < n1; i1++)
        {
            pDst[n2 * i1 + i2].re = tmpDst[i1 + i2 * n1].re;
            pDst[n2 * i1 + i2].im = tmpDst[i1 + i2 * n1].im;
        }
    }
    return;
}
```
